options {Ignore_Case = false;}
PARSER_BEGIN(Analyzer)

public class Analyzer{
    public static void main (String args[]) throws ParseException{
        Analyzer miniJavaAnalizer=new Analyzer(System.in);
        miniJavaAnalizer.Program();
    }
}

PARSER_END(Analyzer)

SKIP:{" " | "\n" | "\t" | "\r"}

SKIP :{< "//" (~["\r", "\n"])* >}

SKIP:{ < "/*" > : mlComment}

<mlComment>SKIP :
{
  < "*/" > : DEFAULT
}

<mlComment> MORE:
{
  <~[]>
}

//Tokens
//----------------------------------------------------
//Reserved words
//----------------------------------------------------
TOKEN: {
    <classToken: "class">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada class");} 
}

TOKEN: {
    <publicToken: "public">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada public");} 
}

TOKEN: {
    <staticToken: "static">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada static");} 
}

TOKEN: {
    <voidToken: "void">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada void");} 
}

TOKEN: {
    <mainToken: "main">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada main");}
}


TOKEN: {
    <stringToken: "String">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada String");} 
} 

TOKEN: {
    <returnToken: "return">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada return");} 
}

TOKEN: {
    <extendsToken: "extends">
    {System.out.println(matchedToken.beginLine +": Palabra reservada extends");} 
}

TOKEN: {
    <intToken: "int">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada int");} 
}

TOKEN: {
    <booleanToken: "boolean">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada boolean");} 
}

TOKEN: {
    <floatToken: "float">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada float");} 
}

TOKEN: {
    <ifToken: "if">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada  if");} 
}

TOKEN: {
    <elseToken: "else">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada else");} 
}

TOKEN: {
    <whileToken: "while">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada while");} 
}

TOKEN: {
    <trueToken: "true">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada true");} 
}

TOKEN: {
    <falseToken: "false">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada false");} 
}

TOKEN: {
    <thisToken: "this">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada this");} 
}

TOKEN: {
    <newToken: "new">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada new");} 
}

TOKEN: {
    <soutToken: "System.out.println">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada System.out.println");} 
}


TOKEN: {
    <lengthToken: "length">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada length");} 
}

//Grouping symbols
//----------------------------------------------------
TOKEN: {
    <openedBraceToken: "[">
    {System.out.println(matchedToken.beginLine + ": corchete abre");} 
}

TOKEN: {
    <closedBraceToken: "]">
    {System.out.println(matchedToken.beginLine + ": corchete cierra");} 
}

TOKEN: {
    <openedParenthesisToken: "(">
    {System.out.println(matchedToken.beginLine + ": Parentesis abre");} 
}

TOKEN: {
    <closedParenthesisToken: ")">
    {System.out.println(matchedToken.beginLine + ": Parentesis cierra");} 
}

TOKEN: {
    <openedCurlyBracketsToken: "{">
    {System.out.println(matchedToken.beginLine + ": Llave abre");} 
}

TOKEN: {
    <closedCurlyBracketsToken: "}">
    {System.out.println(matchedToken.beginLine + ": Llave cierra");} 
}

TOKEN: {
    <semiColonToken: ";">
    {System.out.println(matchedToken.beginLine + ": Punto y coma");}
}

//Operator symbols
//----------------------------------------------------
TOKEN: {
    <equalsToken: "=">
    {System.out.println(matchedToken.beginLine + ": Operador =");} 
}

TOKEN: {
    <comparationToken: "==">
    {System.out.println(matchedToken.beginLine + ": Operador ==");} 
}

TOKEN: {
    <andToken: "&&">
    {System.out.println(matchedToken.beginLine + ": Operador &&");} 
}

TOKEN: {
    <orToken: "||">
    {System.out.println(matchedToken.beginLine + ": Operador |");} 
}

TOKEN: {
    <lessThanToken: "<">
    {System.out.println(matchedToken.beginLine + ": Operador <");} 
}

TOKEN: {
    <moreThanToken: ">">
    {System.out.println(matchedToken.beginLine + ": Operador >");} 
}

TOKEN: {
    <lessOrEqualThanToken: "<=">
    {System.out.println(matchedToken.beginLine + ": Operador <=");} 
}

TOKEN: {
    <moreOrEqualThanToken: ">=">
    {System.out.println(matchedToken.beginLine + ": Operador >=");} 
}

TOKEN: {
    <plusToken: "+">
    {System.out.println(matchedToken.beginLine + ": Operador +");} 
}

TOKEN: {
<minusToken: "-">
{System.out.println(matchedToken.beginLine + ": Operador -");} 
}

TOKEN: {
    <multiplicationToken: "*">
    {System.out.println(matchedToken.beginLine + ": Operador *");} 
}

TOKEN: {
<divisionToken: "/">
{System.out.println(matchedToken.beginLine + ": Operador /");} 
}

TOKEN: {
    <dotToken: ".">
    {System.out.println(matchedToken.beginLine + ": Operador .");} 
}

TOKEN: {
    <commaToken: ",">
    {System.out.println(matchedToken.beginLine + ": separador ,");} 
}

TOKEN: {
    <notToken: "!">
    {System.out.println(matchedToken.beginLine + ": Operador !");} 
}

TOKEN: {
    <idToken: ((["a"-"z"]) | (["A"-"Z"]))
    ((["0"-"9"]){0,} | ("_"){0,} | (["a"-"z"]){0,} | (["A"-"Z"]){0,}){0,}>
    {System.out.println(matchedToken.beginLine + ": Identificador: " + image);} 
}

//Real constants
//------------------------------------
TOKEN:{
    <realConstToken: (["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))"."(["0"-"9"]){1,11}>
    {System.out.println(matchedToken.beginLine + ": Constante real " + image);}
}

//Real ints
//------------------------------------
TOKEN:{
    <intConstToken: (["0"-"9"] | (["1"-"9"](["0"-"9"])+))>
    {System.out.println(matchedToken.beginLine + ": Constante entera " + image);}
}

//Errors
//------------------------------------


/*this token catches wrong float numbers which follow the pattern: n (enters). 
 0 or more enters
 n is a number up to 11 digits
*/
SPECIAL_TOKEN:{
<floatWithoutAnythingAfterPoint:(["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))(" ")*".">
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong float numbers which follow the pattern: . (enters) n
 0 or more enters
 n is a number up to 11 digits
*/

SPECIAL_TOKEN:{
<floatWithoutAnythingBeforePoint: "." (" ")* (["0"-"9"]){1,11}>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong float numbers which follow the pattern: n (enters). (enters) n 
 n is a number up to 11 digits
*/
SPECIAL_TOKEN:{
<floatWithEntersBetweenDigits: (["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))(" ")*"."(" ")*(["0"-"9"]){1,11}>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong id's which starts with numbers instead of letters*/
SPECIAL_TOKEN:{
<iDStartsWithNumber: (["0"-"9"]){0,} <idToken>>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", el identificador " + image + " no debe inciar con un n√∫mero");}
}

SPECIAL_TOKEN: {
    <errorSymbNotIdent: ~[] >
    {System.out.println("ERROR (Simbolo no identificado): " 
    + image + 
    " , en la linea: " + matchedToken.beginLine);}
}



/*
*****************************SINTAXIS*****************************
*/
void Program():{}
{
MainClass() (ClassDeclaration())* <EOF>
}

void MainClass():{}
{
<classToken> Identifier() <openedCurlyBracketsToken> <publicToken> <staticToken> <voidToken>
<mainToken> <openedParenthesisToken> <stringToken> <openedBraceToken> <closedBraceToken>
Identifier() <closedParenthesisToken> <openedCurlyBracketsToken> Statement() <closedCurlyBracketsToken>
<closedCurlyBracketsToken>
}

void ClassDeclaration(): {}
{
<classToken> Identifier() (<extendsToken> Identifier())? <openedCurlyBracketsToken>
(VarDeclaration())* (MethodDeclaration())* <closedCurlyBracketsToken>
}


void VarDeclaration():{}
{
Type() Identifier() TwoOrMoreVar() <semiColonToken>
}


void TwoOrMoreVar():{}
{
(LOOKAHEAD(2)<commaToken> Identifier())*
}

void MethodDeclaration():{}
{
<publicToken> Type() Identifier() <openedParenthesisToken> (Type() Identifier() ( <commaToken> Type() Identifier())* )?
<closedParenthesisToken> <openedCurlyBracketsToken> (LOOKAHEAD(2)VarDeclaration())* (Statement())* 
<returnToken> Expression() <semiColonToken> <closedCurlyBracketsToken>
}


void Type():{}
{
LOOKAHEAD(2) <intToken> <openedBraceToken> <closedBraceToken> 
|<booleanToken> | <intToken> | LOOKAHEAD(2) <floatToken> | <stringToken> 
| Identifier()
| <floatToken> <openedBraceToken> <closedBraceToken>
}

void Statement():{}
{
<openedCurlyBracketsToken>(Statement())*<closedCurlyBracketsToken>
| <ifToken> <openedParenthesisToken> Expression() <closedParenthesisToken> Statement() <elseToken> Statement()
|<whileToken> <openedParenthesisToken> Expression() <closedParenthesisToken> Statement()
| <soutToken> <openedParenthesisToken> Expression() <closedParenthesisToken> <semiColonToken>
| LOOKAHEAD(2) Identifier() <equalsToken> Expression() <semiColonToken>
| Identifier() <openedBraceToken> Expression() <closedBraceToken> <equalsToken> Expression() <semiColonToken>
}

void Expression():{}
{
<intConstToken>ExpressionPrime()
| <realConstToken>ExpressionPrime()
|<trueToken>ExpressionPrime()
| <falseToken>ExpressionPrime()
|Identifier()ExpressionPrime()
|<thisToken>ExpressionPrime()
|LOOKAHEAD(2) <newToken><intToken><openedBraceToken> Expression() <closedBraceToken> ExpressionPrime()
| <newToken> Identifier() <openedParenthesisToken> <closedParenthesisToken> ExpressionPrime()
|<notToken>Expression()ExpressionPrime()
|<openedParenthesisToken>Expression()<closedParenthesisToken>ExpressionPrime()
}

void ExpressionPrime():{}
{
(           
(
<andToken> | <orToken> | <lessThanToken> | <moreThanToken> |
<lessOrEqualThanToken> | <moreOrEqualThanToken> | <plusToken> |
<minusToken> | <multiplicationToken> | <divisionToken> | <comparationToken>
)Expression() ExpressionPrime()
| <openedBraceToken> Expression() <closedBraceToken> ExpressionPrime()
|LOOKAHEAD(2) <dotToken> <lengthToken> ExpressionPrime()
|<dotToken> Identifier() <openedParenthesisToken> (Expression() (<commaToken> Expression())*)? <closedParenthesisToken> ExpressionPrime()
)*
}

void Identifier():{}
{
<idToken>
}