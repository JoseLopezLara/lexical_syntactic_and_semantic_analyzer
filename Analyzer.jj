options {
Ignore_Case = false;
//STATIC=false;
//DEBUG_PARSER=true;
//DEBUG_LOOKAHEAD=true;
}
PARSER_BEGIN(Analyzer)
import java.lang.*;
import java.util.HashMap;
import java.util.Map;

public class Analyzer{
    static HashMap <String, Object> hashMap = new HashMap <String, Object> ();

    public static void main (String args[]) throws ParseException{
        Analyzer miniJavaAnalizer=new Analyzer(System.in);
        miniJavaAnalizer.Program();
        printTable();
		System.out.println("Compilacion exitosa");
    }


public static void insert(String id, String dataType, String category, String size){
    Symbol symbol = new Symbol(id , dataType, category, size);
    hashMap.put(id,symbol);
}

public static Symbol busqueda(String id){
if (hashMap.containsKey(id)) {
    Symbol symbolFound = (Symbol) hashMap.get(id);
	return symbolFound;
}else{
	return null;
}
}

public static void resultadoBusqueda(String id, String catId){
Symbol foundSymbol=busqueda(id);
System.out.println("Analizando " + id);
if(foundSymbol!=null){
if(foundSymbol.getCategory().equals(catId)){
System.out.println("Encontrado " + id + " es " + foundSymbol.getCategory());
}
}
else{
System.out.println(id + " no existe " + catId );
}
}



public static void delete(String id){
    hashMap.remove(id);
}

public static void printTable(){
    System.out.println("----------------------");
    System.out.println("TABLA DE SIMBOLOS: ");
    for (String i : hashMap.keySet()) {
        System.out.println(hashMap.get(i));
    }
}


public static class Symbol {
 String id, dataType, category, size;
	public Symbol(String id, String dataType, String category, String size){
		this.id=id;
		this.dataType=dataType;
        this.category=category;
        this.size=size;
	}

    String getId(){
        return id;
    }
    String getDataType(){
        return dataType;
    }
    String getCategory(){
        return category;
    }
    String getSize(){
        return size;
    }
	
	void setSize(String size){
        this.size=size;
    }

    public String toString(){
    return getId()+ "-" + getDataType()+ "-" + getCategory()+ "-" + getSize();        
  }
}

}


PARSER_END(Analyzer)

SKIP:{" " | "\n" | "\t" | "\r"}

SKIP :{< "//" (~["\r", "\n"])* >}

SKIP:{ < "/*" > : mlComment}

<mlComment>SKIP :
{
  < "*/" > : DEFAULT
}

<mlComment> MORE:
{
  <~[]>
}

//Tokens
//----------------------------------------------------
//Reserved words
//----------------------------------------------------
TOKEN: {
    <classToken: "class">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada class");} 
}

TOKEN: {
    <publicToken: "public">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada public");} 
}

TOKEN: {
    <staticToken: "static">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada static");} 
}

TOKEN: {
    <voidToken: "void">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada void");} 
}

TOKEN: {
    <mainToken: "main">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada main");}
}


TOKEN: {
    <stringToken: "String">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada String");} 
} 

TOKEN: {
    <returnToken: "return">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada return");} 
}

TOKEN: {
    <extendsToken: "extends">
    {System.out.println(matchedToken.beginLine +": Palabra reservada extends");} 
}

TOKEN: {
    <intToken: "int">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada int");} 
}

TOKEN: {
    <booleanToken: "boolean">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada boolean");} 
}

TOKEN: {
    <floatToken: "float">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada float");} 
}

TOKEN: {
    <ifToken: "if">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada  if");} 
}

TOKEN: {
    <elseToken: "else">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada else");} 
}

TOKEN: {
    <whileToken: "while">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada while");} 
}

TOKEN: {
    <trueToken: "true">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada true");} 
}

TOKEN: {
    <falseToken: "false">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada false");} 
}

TOKEN: {
    <thisToken: "this">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada this");} 
}

TOKEN: {
    <newToken: "new">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada new");} 
}

TOKEN: {
    <soutToken: "System.out.println">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada System.out.println");} 
}


TOKEN: {
    <lengthToken: "length">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada length");} 
}

//Grouping symbols
//----------------------------------------------------
TOKEN: {
    <openedBraceToken: "[">
    {System.out.println(matchedToken.beginLine + ": corchete abre");} 
}

TOKEN: {
    <closedBraceToken: "]">
    {System.out.println(matchedToken.beginLine + ": corchete cierra");} 
}

TOKEN: {
    <openedParenthesisToken: "(">
    {System.out.println(matchedToken.beginLine + ": Parentesis abre");} 
}

TOKEN: {
    <closedParenthesisToken: ")">
    {System.out.println(matchedToken.beginLine + ": Parentesis cierra");} 
}

TOKEN: {
    <openedCurlyBracketsToken: "{">
    {System.out.println(matchedToken.beginLine + ": Llave abre");} 
}

TOKEN: {
    <closedCurlyBracketsToken: "}">
    {System.out.println(matchedToken.beginLine + ": Llave cierra");} 
}

TOKEN: {
    <semiColonToken: ";">
    {System.out.println(matchedToken.beginLine + ": Punto y coma");}
}

//Operator symbols
//----------------------------------------------------
TOKEN: {
    <equalsToken: "=">
    {System.out.println(matchedToken.beginLine + ": Operador =");} 
}

TOKEN: {
    <comparationToken: "==">
    {System.out.println(matchedToken.beginLine + ": Operador ==");} 
}

TOKEN: {
    <andToken: "&&">
    {System.out.println(matchedToken.beginLine + ": Operador &&");} 
}

TOKEN: {
    <orToken: "||">
    {System.out.println(matchedToken.beginLine + ": Operador |");} 
}

TOKEN: {
    <lessThanToken: "<">
    {System.out.println(matchedToken.beginLine + ": Operador <");} 
}

TOKEN: {
    <moreThanToken: ">">
    {System.out.println(matchedToken.beginLine + ": Operador >");} 
}

TOKEN: {
    <lessOrEqualThanToken: "<=">
    {System.out.println(matchedToken.beginLine + ": Operador <=");} 
}

TOKEN: {
    <moreOrEqualThanToken: ">=">
    {System.out.println(matchedToken.beginLine + ": Operador >=");} 
}

TOKEN: {
    <plusToken: "+">
    {System.out.println(matchedToken.beginLine + ": Operador +");} 
}

TOKEN: {
<minusToken: "-">
{System.out.println(matchedToken.beginLine + ": Operador -");} 
}

TOKEN: {
    <multiplicationToken: "*">
    {System.out.println(matchedToken.beginLine + ": Operador *");} 
}

TOKEN: {
<divisionToken: "/">
{System.out.println(matchedToken.beginLine + ": Operador /");} 
}

TOKEN: {
    <dotToken: ".">
    {System.out.println(matchedToken.beginLine + ": Operador .");} 
}

TOKEN: {
    <commaToken: ",">
    {System.out.println(matchedToken.beginLine + ": separador ,");} 
}

TOKEN: {
    <notToken: "!">
    {System.out.println(matchedToken.beginLine + ": Operador !");} 
}

TOKEN: {
    <idToken: ((["a"-"z"]) | (["A"-"Z"]))
    ((["0"-"9"]){0,} | ("_"){0,} | (["a"-"z"]){0,} | (["A"-"Z"]){0,}){0,}>
    {System.out.println(matchedToken.beginLine + ": Identificador: " + image);} 
}

//Real constants
//------------------------------------
TOKEN:{
    <realConstToken: (["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))"."(["0"-"9"]){1,11}>
    {System.out.println(matchedToken.beginLine + ": Constante real " + image);}
}

//Real ints
//------------------------------------
TOKEN:{
    <intConstToken: (["0"-"9"] | (["1"-"9"](["0"-"9"])+))>
    {System.out.println(matchedToken.beginLine + ": Constante entera " + image);}
}

//Errors
//------------------------------------


/*this token catches wrong float numbers which follow the pattern: n (enters). 
 0 or more enters
 n is a number up to 11 digits
*/
SPECIAL_TOKEN:{
<floatWithoutAnythingAfterPoint:(["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))(" ")*".">
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong float numbers which follow the pattern: . (enters) n
 0 or more enters
 n is a number up to 11 digits
*/

SPECIAL_TOKEN:{
<floatWithoutAnythingBeforePoint: "." (" ")* (["0"-"9"]){1,11}>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong float numbers which follow the pattern: n (enters). (enters) n 
 n is a number up to 11 digits
*/
SPECIAL_TOKEN:{
<floatWithEntersBetweenDigits: (["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))(" ")*"."(" ")*(["0"-"9"]){1,11}>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong id's which starts with numbers instead of letters*/
SPECIAL_TOKEN:{
<iDStartsWithNumber: (["0"-"9"]){0,} <idToken>>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", el identificador " + image + " no debe inciar con un número");}
}

SPECIAL_TOKEN: {
    <errorSymbNotIdent: ~[] >
    {System.out.println("ERROR (Simbolo no identificado): " 
    + image + 
    " , en la linea: " + matchedToken.beginLine);}
}



/*
*****************************SINTAXIS*****************************
*/
void Program():{}
{
MainClass() (ClassDeclaration())* <EOF>
}

void MainClass():{}
{
<classToken> <idToken>{String image=token.image;
insert(image, "void", "clase", "0");
} <openedCurlyBracketsToken> <publicToken> <staticToken> <voidToken>
<mainToken> <openedParenthesisToken> <stringToken> <openedBraceToken> <closedBraceToken>
<idToken>{image=token.image;
insert(image, "void", "arreglo", "0");
} <closedParenthesisToken> <openedCurlyBracketsToken> Statement() <closedCurlyBracketsToken>
<closedCurlyBracketsToken>
}

void ClassDeclaration(): {}
{
<classToken> <idToken>
{String image=token.image;
insert(image, "void", "clase", "0");
}
(<extendsToken> <idToken>)? <openedCurlyBracketsToken>
(VarDeclaration())* (MethodDeclaration())* <closedCurlyBracketsToken>
}


void VarDeclaration():{String type=""; String image; int tam=0; String category="";}
{
type=Type() <idToken>
{
image=token.image;
if(type.equals("arreglo-float")){category="arreglo"; insert(image, "float", "arreglo", tam+"");} 
else if(type.equals("arreglo-int")){category="arreglo"; insert(image, "int", "arreglo", tam+"");}
else{ category="variable"; insert(image, type, "variable", "0"); }
}
 TwoOrMoreVar(type, category, tam+"") <semiColonToken>
}

void TwoOrMoreVar(String type, String category, String tam):{String image;}
{
(LOOKAHEAD(2)<commaToken> <idToken> {image=token.image; insert(image, type, category, tam); })*
}


void MethodDeclaration():{String type; int tam=0; String dataReturn="void";}
{
<publicToken> type=Type() <idToken>{String imageMethod=token.image;}
<openedParenthesisToken> (type=Type() <idToken>{String image=token.image;
if(type.equals("arreglo-float"))insert(image, "float", "arreglo", "0"); 
else if(type.equals("arreglo-int"))insert(image, "int", "arreglo", "0");
else insert(image, type, "variable", "0"); 
tam++;
} ( <commaToken> type=Type() <idToken>{image=token.image;
if(type.equals("arreglo-float"))insert(image, "float", "arreglo", "0"); 
else if(type.equals("arreglo-int"))insert(image, "int", "arreglo", "0");
else insert(image, type, "variable", "0"); 
tam++;
})* )?
{insert(imageMethod, type, "Funcion", tam+"");}
<closedParenthesisToken> <openedCurlyBracketsToken> (LOOKAHEAD(2)VarDeclaration())* (Statement())* 
<returnToken> dataReturn=Expression(0, "") 
{
if(!type.equals(dataReturn))
{
System.out.println( "Tipos de datos inconsistentes. Método: " + type + " retorno: " + dataReturn);
}

else{
System.out.println( "Tipos de datos iguales. Método: " + type + " retorno: " + dataReturn);
}
} 
<semiColonToken> <closedCurlyBracketsToken>
}

String Type():{}
{
LOOKAHEAD(2) <intToken> <openedBraceToken> <closedBraceToken> {return "arreglo-int";}
|<booleanToken> {return "boolean";} | <intToken> {return "int";} | LOOKAHEAD(2) <floatToken>{return "float";} | <stringToken> {return "String";}
| <idToken>{return token.image;}
| <floatToken> <openedBraceToken> <closedBraceToken> {return "arreglo-float";}

}

void Statement():{String lexeme; String dataType=""; String returnDataType=""; boolean fSymbol=false; int arraySize=0; String arrayName="";}
{
<openedCurlyBracketsToken>(Statement())*<closedCurlyBracketsToken>
| <ifToken> <openedParenthesisToken> Expression(0, "") <closedParenthesisToken> Statement() <elseToken> Statement()
|<whileToken> <openedParenthesisToken> Expression(0, "") <closedParenthesisToken> Statement()
| <soutToken> <openedParenthesisToken> Expression(0, "") <closedParenthesisToken> <semiColonToken>

//---------------Expresiones del tipo a=b;---------------
|LOOKAHEAD(2)<idToken>
{
lexeme = token.image;
Symbol foundSymbol=busqueda(lexeme);
System.out.println("Analizando " + lexeme);
if(foundSymbol!=null){
if(foundSymbol.getCategory().equals("variable")){
dataType= foundSymbol.getDataType();

//Checks if variable exists before check if its value it's correct
fSymbol=true;
System.out.println("Encontrado " + lexeme + " es " + foundSymbol.getCategory() + " tipo: " + dataType);
}

if(foundSymbol.getCategory().equals("arreglo")){
arrayName=lexeme;
}
}
else{
fSymbol=false;
System.out.println(lexeme + " no existe ");
}
} 
<equalsToken> returnDataType=Expression(0, arrayName) 
{
if(fSymbol && dataType.equals(returnDataType))
{
System.out.println("Correcto, tipo de dato: "  + dataType + " asignado " + returnDataType);
}

else if (fSymbol && returnDataType.equals("noApply")){
System.out.println("Correcto, tipo de dato: "  + dataType + " asignado " + dataType);
}

else if(fSymbol && !dataType.equals(returnDataType)){
if(returnDataType.equals("AritmeticError")){
System.out.println("Error, algun o algunos datos de la expresión NO son números");
}

else
System.out.println("Error, tipo de dato: " + dataType + " asignado " + returnDataType);
}
} <semiColonToken>

//---------------Expresiones del tipo a[expresión()]=expresión();---------------
|<idToken> 
{
lexeme = token.image;
Symbol foundSymbol=busqueda(lexeme);
System.out.println("Analizando " + lexeme);
if(foundSymbol!=null){
if(foundSymbol.getCategory().equals("arreglo")){
dataType= foundSymbol.getDataType();
arraySize= Integer.parseInt(foundSymbol.getSize());
//Checks if variable exists before check if its value it's correct
fSymbol=true;
System.out.println("Encontrado " + lexeme + " es " + foundSymbol.getCategory() + "tipo: " + dataType);
}
}
else{
fSymbol=false;
System.out.println(lexeme + " no existe ");
}
}
<openedBraceToken> Expression(arraySize, "") <closedBraceToken> <equalsToken> returnDataType=Expression(0, "") 
{
if(fSymbol && dataType.equals(returnDataType))
{
System.out.println("Correcto, tipo de dato: "  + dataType + " asignado " + returnDataType);
}
else if(fSymbol && !dataType.equals(returnDataType)){
if(returnDataType.equals("AritmeticError")){
System.out.println("Error, algun o algunos datos de la expresión NO son números");
}
else
System.out.println("Error, tipo de dato: " + dataType + " asignado " + returnDataType);
}
}

<semiColonToken>
}




String Expression(int arraySize, String arrayName):{String lexeme; String dataReturn="void"; String nextDataType="";}
{
<intConstToken> 
{
lexeme = token.image;
int lexemeValue = Integer.parseInt(lexeme);

if(!arrayName.equals("")){
Symbol foundSymbol=busqueda(arrayName);
foundSymbol.setSize(lexeme);
hashMap.put(arrayName,foundSymbol);
}

if(arraySize>0 && lexemeValue>arraySize){
System.out.println("La posición (" + lexemeValue +") supera el tamaño del arreglo (" + arraySize + ")" );
}
dataReturn="int";
}
nextDataType=ExpressionPrime(dataReturn) 
{ 
if (!dataReturn.equals(nextDataType)) 
dataReturn=nextDataType;
return dataReturn;
}

| <realConstToken>{dataReturn="float";}nextDataType=ExpressionPrime(dataReturn)
{ 
if (!dataReturn.equals(nextDataType)) 
dataReturn=nextDataType;
return dataReturn;
}

|<trueToken>{dataReturn="boolean";}nextDataType=ExpressionPrime(dataReturn)
{ 
if (!dataReturn.equals(nextDataType)) 
dataReturn=nextDataType;
return dataReturn;
}
| <falseToken>{dataReturn="boolean";}nextDataType=ExpressionPrime(dataReturn) 
{ 
if (!dataReturn.equals(nextDataType)) 
dataReturn=nextDataType;
return dataReturn;
}

//---------------Expresiones del tipo a=b;---------------
|<idToken> 
{
lexeme = token.image;
Symbol foundSymbol=busqueda(lexeme);
System.out.println("Analizando " + lexeme);
if(foundSymbol!=null){
if(foundSymbol.getCategory().equals("variable")){
dataReturn= foundSymbol.getDataType();
System.out.println("Encontrado " + lexeme + " es " + foundSymbol.getCategory() + " tipo: " + dataReturn);
}

if(foundSymbol.getCategory().equals("arreglo")){
dataReturn= foundSymbol.getDataType();
System.out.println("Encontrado " + lexeme + " es " + foundSymbol.getCategory() + " tipo: " + dataReturn);
}
}
else{
System.out.println(lexeme + " no existe ");
}
} nextDataType = ExpressionPrime(dataReturn) 
{ 
if (!dataReturn.equals(nextDataType)) 
dataReturn=nextDataType;
return dataReturn;
}

|<thisToken>ExpressionPrime(dataReturn) {return "noApply";}
|LOOKAHEAD(2) <newToken><intToken><openedBraceToken> Expression(0,arrayName) <closedBraceToken> ExpressionPrime(dataReturn) {return dataReturn;}
| <newToken> <idToken><openedParenthesisToken> <closedParenthesisToken> ExpressionPrime(dataReturn) {return dataReturn;}
|<notToken>Expression(0, "")ExpressionPrime(dataReturn) {return dataReturn;}
|<openedParenthesisToken>Expression(0, "")<closedParenthesisToken>ExpressionPrime(dataReturn) {return "noApply";}
}




String ExpressionPrime(String previousDataType):{String dataType=""; String dataReturn=previousDataType; char aritmeticOperator='n';}
{
(         
(
<andToken> | <orToken> | <lessThanToken> | <moreThanToken> |
<lessOrEqualThanToken> | <moreOrEqualThanToken> | <plusToken> {aritmeticOperator='+';} |
<minusToken> {aritmeticOperator='-';} | <multiplicationToken> {aritmeticOperator='*';} | <divisionToken> {aritmeticOperator='/';} | <comparationToken>
)dataType=Expression(0, "") 
{
if(previousDataType.equals(dataType)){
dataReturn=previousDataType;
}

else if(!dataType.equals("noApply")){
dataReturn="Error";
}

// Check if both values are numbers in aritmetic expressions
if(aritmeticOperator!='n' && !dataType.equals("noApply")){
 if((!previousDataType.equals("int") && !previousDataType.equals("float")) || (!dataType.equals("int") && !dataType.equals("float"))){
	dataReturn="AritmeticError";		
  }
}

//System.out.println("Tipo pasado " + previousDataType + " tipo sig " + dataType + " retorna " + dataReturn);
}
ExpressionPrime(dataReturn){return dataReturn;}

|LOOKAHEAD(2)<openedBraceToken> Expression(0, "") <closedBraceToken> ExpressionPrime(dataReturn){return dataReturn;}
|LOOKAHEAD(2) <dotToken> <lengthToken> ExpressionPrime(dataReturn){return previousDataType;}
|LOOKAHEAD(2)<dotToken><idToken><openedParenthesisToken> (Expression(0, "") (<commaToken> Expression(0, ""))*)? <closedParenthesisToken> ExpressionPrime(dataReturn){return previousDataType;}
)*{return dataReturn;}
}
