options {
Ignore_Case = false;
//STATIC=false;
//DEBUG_PARSER=true;
//DEBUG_LOOKAHEAD=true;
}
PARSER_BEGIN(Analyzer)
import java.lang.*;
import java.util.HashMap;
import java.util.Map;

public class Analyzer{
    static HashMap <String, Object> hashMap = new HashMap <String, Object> ();

    public static void main (String args[]) throws ParseException{
        Analyzer miniJavaAnalizer=new Analyzer(System.in);
        miniJavaAnalizer.Program();
        printTable();
		System.out.println("Compilacion exitosa");
    }


public static void busqueda(String id, String dataType, String category, String size){
    Symbol symbol = new Symbol(id , dataType, category, size);

if (hashMap.containsKey(id)) {
    Symbol symbolFound = (Symbol) hashMap.get(id);
    if(!symbol.toString().equals(symbolFound.toString())){//Atributos Diferentes
    System.out.println("-Different: "+id);
        insert(id, symbol);
    }
}else{
    insert(id, symbol);
}
}


public static void insert(String id, Symbol symbol){
    hashMap.put(id,symbol);
}

public static void delete(String id){
    hashMap.remove(id);
}

public static void printTable(){
    System.out.println("----------------------");
    System.out.println("TABLA DE SIMBOLOS: ");
    for (String i : hashMap.keySet()) {
        System.out.println(hashMap.get(i));
    }
}


public static class Symbol {
 String id, dataType, category, size;
	public Symbol(String id, String dataType, String category, String size){
		this.id=id;
		this.dataType=dataType;
        this.category=category;
        this.size=size;
	}

    String getId(){
        return id;
    }
    String getDataType(){
        return dataType;
    }
    String getCategory(){
        return category;
    }
    String getSize(){
        return size;
    }

    public String toString(){
    return getId()+ "-" + getDataType()+ "-" + getCategory()+ "-" + getSize();        
  }
}

}


PARSER_END(Analyzer)

SKIP:{" " | "\n" | "\t" | "\r"}

SKIP :{< "//" (~["\r", "\n"])* >}

SKIP:{ < "/*" > : mlComment}

<mlComment>SKIP :
{
  < "*/" > : DEFAULT
}

<mlComment> MORE:
{
  <~[]>
}

//Tokens
//----------------------------------------------------
//Reserved words
//----------------------------------------------------
TOKEN: {
    <classToken: "class">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada class");} 
}

TOKEN: {
    <publicToken: "public">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada public");} 
}

TOKEN: {
    <staticToken: "static">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada static");} 
}

TOKEN: {
    <voidToken: "void">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada void");} 
}

TOKEN: {
    <mainToken: "main">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada main");}
}


TOKEN: {
    <stringToken: "String">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada String");} 
} 

TOKEN: {
    <returnToken: "return">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada return");} 
}

TOKEN: {
    <extendsToken: "extends">
    {System.out.println(matchedToken.beginLine +": Palabra reservada extends");} 
}

TOKEN: {
    <intToken: "int">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada int");} 
}

TOKEN: {
    <booleanToken: "boolean">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada boolean");} 
}

TOKEN: {
    <floatToken: "float">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada float");} 
}

TOKEN: {
    <ifToken: "if">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada  if");} 
}

TOKEN: {
    <elseToken: "else">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada else");} 
}

TOKEN: {
    <whileToken: "while">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada while");} 
}

TOKEN: {
    <trueToken: "true">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada true");} 
}

TOKEN: {
    <falseToken: "false">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada false");} 
}

TOKEN: {
    <thisToken: "this">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada this");} 
}

TOKEN: {
    <newToken: "new">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada new");} 
}

TOKEN: {
    <soutToken: "System.out.println">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada System.out.println");} 
}


TOKEN: {
    <lengthToken: "length">
    {System.out.println(matchedToken.beginLine + ": Palabra reservada length");} 
}

//Grouping symbols
//----------------------------------------------------
TOKEN: {
    <openedBraceToken: "[">
    {System.out.println(matchedToken.beginLine + ": corchete abre");} 
}

TOKEN: {
    <closedBraceToken: "]">
    {System.out.println(matchedToken.beginLine + ": corchete cierra");} 
}

TOKEN: {
    <openedParenthesisToken: "(">
    {System.out.println(matchedToken.beginLine + ": Parentesis abre");} 
}

TOKEN: {
    <closedParenthesisToken: ")">
    {System.out.println(matchedToken.beginLine + ": Parentesis cierra");} 
}

TOKEN: {
    <openedCurlyBracketsToken: "{">
    {System.out.println(matchedToken.beginLine + ": Llave abre");} 
}

TOKEN: {
    <closedCurlyBracketsToken: "}">
    {System.out.println(matchedToken.beginLine + ": Llave cierra");} 
}

TOKEN: {
    <semiColonToken: ";">
    {System.out.println(matchedToken.beginLine + ": Punto y coma");}
}

//Operator symbols
//----------------------------------------------------
TOKEN: {
    <equalsToken: "=">
    {System.out.println(matchedToken.beginLine + ": Operador =");} 
}

TOKEN: {
    <comparationToken: "==">
    {System.out.println(matchedToken.beginLine + ": Operador ==");} 
}

TOKEN: {
    <andToken: "&&">
    {System.out.println(matchedToken.beginLine + ": Operador &&");} 
}

TOKEN: {
    <orToken: "||">
    {System.out.println(matchedToken.beginLine + ": Operador |");} 
}

TOKEN: {
    <lessThanToken: "<">
    {System.out.println(matchedToken.beginLine + ": Operador <");} 
}

TOKEN: {
    <moreThanToken: ">">
    {System.out.println(matchedToken.beginLine + ": Operador >");} 
}

TOKEN: {
    <lessOrEqualThanToken: "<=">
    {System.out.println(matchedToken.beginLine + ": Operador <=");} 
}

TOKEN: {
    <moreOrEqualThanToken: ">=">
    {System.out.println(matchedToken.beginLine + ": Operador >=");} 
}

TOKEN: {
    <plusToken: "+">
    {System.out.println(matchedToken.beginLine + ": Operador +");} 
}

TOKEN: {
<minusToken: "-">
{System.out.println(matchedToken.beginLine + ": Operador -");} 
}

TOKEN: {
    <multiplicationToken: "*">
    {System.out.println(matchedToken.beginLine + ": Operador *");} 
}

TOKEN: {
<divisionToken: "/">
{System.out.println(matchedToken.beginLine + ": Operador /");} 
}

TOKEN: {
    <dotToken: ".">
    {System.out.println(matchedToken.beginLine + ": Operador .");} 
}

TOKEN: {
    <commaToken: ",">
    {System.out.println(matchedToken.beginLine + ": separador ,");} 
}

TOKEN: {
    <notToken: "!">
    {System.out.println(matchedToken.beginLine + ": Operador !");} 
}

TOKEN: {
    <idToken: ((["a"-"z"]) | (["A"-"Z"]))
    ((["0"-"9"]){0,} | ("_"){0,} | (["a"-"z"]){0,} | (["A"-"Z"]){0,}){0,}>
    {System.out.println(matchedToken.beginLine + ": Identificador: " + image);} 
}

//Real constants
//------------------------------------
TOKEN:{
    <realConstToken: (["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))"."(["0"-"9"]){1,11}>
    {System.out.println(matchedToken.beginLine + ": Constante real " + image);}
}

//Real ints
//------------------------------------
TOKEN:{
    <intConstToken: (["0"-"9"] | (["1"-"9"](["0"-"9"])+))>
    {System.out.println(matchedToken.beginLine + ": Constante entera " + image);}
}

//Errors
//------------------------------------


/*this token catches wrong float numbers which follow the pattern: n (enters). 
 0 or more enters
 n is a number up to 11 digits
*/
SPECIAL_TOKEN:{
<floatWithoutAnythingAfterPoint:(["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))(" ")*".">
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong float numbers which follow the pattern: . (enters) n
 0 or more enters
 n is a number up to 11 digits
*/

SPECIAL_TOKEN:{
<floatWithoutAnythingBeforePoint: "." (" ")* (["0"-"9"]){1,11}>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong float numbers which follow the pattern: n (enters). (enters) n 
 n is a number up to 11 digits
*/
SPECIAL_TOKEN:{
<floatWithEntersBetweenDigits: (["0"-"9"] | (["1"-"9"](["0"-"9"]){0,10}))(" ")*"."(" ")*(["0"-"9"]){1,11}>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", debido a un numero flotante mal construido: " + image );}
}

/*this token catches wrong id's which starts with numbers instead of letters*/
SPECIAL_TOKEN:{
<iDStartsWithNumber: (["0"-"9"]){0,} <idToken>>
{System.out.println("Error en la linea: " + matchedToken.beginLine + ", el identificador " + image + " no debe inciar con un n√∫mero");}
}

SPECIAL_TOKEN: {
    <errorSymbNotIdent: ~[] >
    {System.out.println("ERROR (Simbolo no identificado): " 
    + image + 
    " , en la linea: " + matchedToken.beginLine);}
}



/*
*****************************SINTAXIS*****************************
*/
void Program():{}
{
MainClass() (ClassDeclaration())* <EOF>
}

void MainClass():{}
{
<classToken> <idToken>{String image=token.image;
busqueda(image, "void", "clase", "");
} <openedCurlyBracketsToken> <publicToken> <staticToken> <voidToken>
<mainToken> <openedParenthesisToken> <stringToken> <openedBraceToken> <closedBraceToken>
<idToken>{image=token.image;
busqueda(image, "void", "arreglo", "0");
} <closedParenthesisToken> <openedCurlyBracketsToken> Statement() <closedCurlyBracketsToken>
<closedCurlyBracketsToken>
}

void ClassDeclaration(): {}
{
<classToken> <idToken>
{String image=token.image;
busqueda(image, "void", "clase", "");
}
(<extendsToken> <idToken>)? <openedCurlyBracketsToken>
(VarDeclaration())* (MethodDeclaration())* <closedCurlyBracketsToken>
}


void VarDeclaration():{String type; String image; int tam=0;}
{
type=Type() <idToken>
{image=token.image;
if(type.equals("arreglo-float"))busqueda(image, "float", "arreglo", tam+""); 
else if(type.equals("arreglo-int"))busqueda(image, "int", "arreglo", tam+"");
else busqueda(image, type, "variable", ""); 
tam++;
}
 TwoOrMoreVar() <semiColonToken>
}


void TwoOrMoreVar():{}
{
(LOOKAHEAD(2)<commaToken> <idToken>)*
}

void MethodDeclaration():{String type; int tam=0;}
{
<publicToken> type=Type() <idToken>{String imageMethod=token.image;}
<openedParenthesisToken> (type=Type() <idToken>{String image=token.image;
System.out.println("----------------------******"+type);
if(type.equals("arreglo-float"))busqueda(image, "float", "arreglo", ""); 
else if(type.equals("arreglo-int"))busqueda(image, "int", "arreglo", "");
else busqueda(image, type, "variable", ""); 
tam++;
} ( <commaToken> type=Type() <idToken>{image=token.image;
System.out.println("----------------------******"+type);
if(type.equals("arreglo-float"))busqueda(image, "float", "arreglo", ""); 
else if(type.equals("arreglo-int"))busqueda(image, "int", "arreglo", "");
else busqueda(image, type, "variable", ""); 
tam++;
})* )?
{busqueda(imageMethod, type, "Funcion", tam+"");}
<closedParenthesisToken> <openedCurlyBracketsToken> (LOOKAHEAD(2)VarDeclaration())* (Statement())* 
<returnToken> Expression() <semiColonToken> <closedCurlyBracketsToken>
}


String Type():{}
{
LOOKAHEAD(2) <intToken> <openedBraceToken> <closedBraceToken> {return "arreglo-int";}
|<booleanToken> {return "boolean";} | <intToken> {return "int";} | LOOKAHEAD(2) <floatToken>{return "float";} | <stringToken> {return "String";}
| <idToken>{return token.image;}
| <floatToken> <openedBraceToken> <closedBraceToken> {return "arreglo-float";}

}

void Statement():{}
{
<openedCurlyBracketsToken>(Statement())*<closedCurlyBracketsToken>
| <ifToken> <openedParenthesisToken> Expression() <closedParenthesisToken> Statement() <elseToken> Statement()
|<whileToken> <openedParenthesisToken> Expression() <closedParenthesisToken> Statement()
| <soutToken> <openedParenthesisToken> Expression() <closedParenthesisToken> <semiColonToken>
|LOOKAHEAD(2)<idToken> <equalsToken> Expression() <semiColonToken>
|<idToken> <openedBraceToken> Expression() <closedBraceToken> <equalsToken> Expression() <semiColonToken>
}

void Expression():{}
{
<intConstToken>ExpressionPrime()
| <realConstToken>ExpressionPrime()
|<trueToken>ExpressionPrime()
| <falseToken>ExpressionPrime()
|<idToken> ExpressionPrime()
|<thisToken>ExpressionPrime()
|LOOKAHEAD(2) <newToken><intToken><openedBraceToken> Expression() <closedBraceToken> ExpressionPrime()
| <newToken> <idToken><openedParenthesisToken> <closedParenthesisToken> ExpressionPrime()
|<notToken>Expression()ExpressionPrime()
|<openedParenthesisToken>Expression()<closedParenthesisToken>ExpressionPrime()
}

void ExpressionPrime():{}
{
(         
(
<andToken> | <orToken> | <lessThanToken> | <moreThanToken> |
<lessOrEqualThanToken> | <moreOrEqualThanToken> | <plusToken> |
<minusToken> | <multiplicationToken> | <divisionToken> | <comparationToken>
)Expression() ExpressionPrime()
| LOOKAHEAD(5)<openedBraceToken> Expression() <closedBraceToken> ExpressionPrime()
|LOOKAHEAD(2) <dotToken> <lengthToken> ExpressionPrime()
|LOOKAHEAD(2)<dotToken> <idToken><openedParenthesisToken> (Expression() (<commaToken> Expression())*)? <closedParenthesisToken> ExpressionPrime()
)*
}
